ABS READING NOTE
================

+ ,
	1 let "t2 = ((a = 9, 15 / 3))" # Set "a = 9" and "t2 = 15 / 3"

+ ,
for file in /{,usr/}bin/*calc
# Find all executable files ending in "calc"
# in /bin and /usr/bin directories.

+ :
It may be considered a synonym for the shell builtin true. The ":" command is itself a Bash builtin, and
its exit status is true (0).
	while true # equal while :

+ :
	: ${HOSTNAME?} ${USER?} ${MAIL?}
	# Prints error message
	#+ if one or more of essential environmental variables not set.

+ :
	: > data.xxx
	# File "data.xxx" now empty.
	# Same effect as
	cat /dev/null >data.xxx
	# However, this does not fork a new process, since ":" is a builtin.

+ *
	echo "Using *"; echo
	for filename in *
	do
	echo "$filename"
	done
	# Lists only files in current directory ($PWD).
	echo; echo "--------------"; echo
	echo "Using **"
	for filename in **
	do
	echo "$filename"
	done
	# Lists complete file tree, recursively.

+ ? 
In a double-parentheses construct, the ? can serve as an element of a C-style trinary operator.
	(( var0 = var1<98?9:21 ))

+ $'...'
The $' ... ' quoted string-expansion construct is a mechanism that uses escaped
octal or hex values to assign ASCII characters to variables, e.g., quote=$'\042'.

+ $$
process ID variable. The $$ variable holds the process ID [19] of the script in which it appears.
	echo $$$$$$$ # Output "<PID><PID><PID>$"

+ ()
A listing of commands within parentheses starts a _subshell_.
	(a=hello; echo $a)

array initialization.
    Array=(element1 element2 element3)

+ {xxx,yyy,zzz,...}
    cat aaa{a,b,c} > b # equal cat aaaa aaab aaac > b

#No spaces allowed within the braces unless the spaces are quoted or escaped.
    echo {file1,file2}\ :{\ A," B",' C'}
    #file1 : A file1 : B file1 : C file2 : A file2 : B file2 : C

    echo {a..z} # a b c d e f g h i j k l m n o p q r s t u v w x y z

# Initializing an array, using extended brace expansion.
    base64_charset=( {A..Z} {a..z} {0..9} + / = )

# Placeholder for text
ls . | xargs -i -t rm my_dir1/my_dir2/{}

+ xargs
Because Unix filenames can contain blanks and newlines, this default behaviour is often  problematic;  file‐
names  containing blanks and/or newlines are incorrectly processed by xargs.  In these situations it is bet‐
ter to use the -0 option, which prevents such problems.   When using this option you  will  need  to  ensure
that the program which produces the input for xargs also uses a null character as a separator.  If that pro‐
gram is GNU find for example, the -print0 option does this for you.

   find /tmp -name core -type f -print | xargs /bin/rm -f

Find  files named core in or below the directory /tmp and delete them.  Note that this will work incorrectly
if there are any filenames containing newlines or spaces.

   find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f

Find files named core in or below the directory /tmp and delete them, processing filenames  in  such  a  way
that file or directory names containing spaces or newlines are correctly handled.

+ (())
Evaluate integer expression between ((...)).
    a=3
    b=7
    echo (($a+$b)) # 10 $[...] is deprecated
    echo (($a*$b)) # 21

+ &>
This is useful for suppressing output when testing for a condition. For example, let us
test whether a certain command exists.
    type bogus_command &>/dev/null
    echo $?

+ 
#-------------------------------------------------------------------------
# No space permitted on either side of = sign when initializing variables.
# What happens if there is a space?
# "VARIABLE =value"
#
#% Script tries to run "VARIABLE" command with one argument, "=value".
# "VARIABLE= value"
#
#% Script tries to run "value" command with
#+ the environmental variable "VARIABLE" set to "".
#-------------------------------------------------------------------------

+ 
# =======================================
# Quoting a variable preserves whitespace.
# =======================================
# Notice the effect of different types of quoting.
    hello="A B C   D"
    hello=A B C   D # gives an error
    hello=A\ B\ C\ \ \ D # also works
    echo $hello # A B C D
    echo "$hello" # A B C   D
    echo '$hello' # $hello

# in FOR operation, the delimiter is whitespace.
# so if $DATA was:
#   aaa
#   bbb
#   ccc
for LINE in $DATA # LINE=aaa, LINE=bbb, LINE=ccc
for LINE in "$DATA" # a whole variable

+ 
#
# An uninitialized variable has no value,
#+ however it evaluates as 0 in an arithmetic operation.
    if [ -z "$unassigned" ]
    then
    echo "\$unassigned is NULL."
    fi
    # $unassigned is NULL.

    echo "$uninitialized" # (blank line)
    let "uninitialized += 5" # Add 5 to it.
    echo "$uninitialized" # 5
