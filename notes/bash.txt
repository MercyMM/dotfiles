ABS READING NOTE
================

+ ,
	1 let "t2 = ((a = 9, 15 / 3))" # Set "a = 9" and "t2 = 15 / 3"

+ ,
for file in /{,usr/}bin/*calc
# Find all executable files ending in "calc"
# in /bin and /usr/bin directories.

+ :
It may be considered a synonym for the shell builtin true. The ":" command is itself a Bash builtin, and
its exit status is true (0).
	while true # equal while :

+ :
	: ${HOSTNAME?} ${USER?} ${MAIL?}
	# Prints error message
	#+ if one or more of essential environmental variables not set.

+ :
	: > data.xxx
	# File "data.xxx" now empty.
	# Same effect as
	cat /dev/null >data.xxx
	# However, this does not fork a new process, since ":" is a builtin.

+ *
	echo "Using *"; echo
	for filename in *
	do
	echo "$filename"
	done
	# Lists only files in current directory ($PWD).
	echo; echo "--------------"; echo
	echo "Using **"
	for filename in **
	do
	echo "$filename"
	done
	# Lists complete file tree, recursively.

+ ? 
In a double-parentheses construct, the ? can serve as an element of a C-style trinary operator.
	(( var0 = var1<98?9:21 ))

+ $'...'
The $' ... ' quoted string-expansion construct is a mechanism that uses escaped
octal or hex values to assign ASCII characters to variables, e.g., quote=$'\042'.

+ $$
process ID variable. The $$ variable holds the process ID [19] of the script in which it appears.
	echo $$$$$$$ # Output "<PID><PID><PID>$"

+ ()
A listing of commands within parentheses starts a _subshell_.
	(a=hello; echo $a)

array initialization.
    Array=(element1 element2 element3)

+ {xxx,yyy,zzz,...}
    cat aaa{a,b,c} > b # equal cat aaaa aaab aaac > b

#No spaces allowed within the braces unless the spaces are quoted or escaped.
    echo {file1,file2}\ :{\ A," B",' C'}
    #file1 : A file1 : B file1 : C file2 : A file2 : B file2 : C

    echo {a..z} # a b c d e f g h i j k l m n o p q r s t u v w x y z

# Initializing an array, using extended brace expansion.
    base64_charset=( {A..Z} {a..z} {0..9} + / = )

# Placeholder for text
ls . | xargs -i -t rm my_dir1/my_dir2/{}

+ xargs
Because Unix filenames can contain blanks and newlines, this default behaviour is often  problematic;  file‐
names  containing blanks and/or newlines are incorrectly processed by xargs.  In these situations it is bet‐
ter to use the -0 option, which prevents such problems.   When using this option you  will  need  to  ensure
that the program which produces the input for xargs also uses a null character as a separator.  If that pro‐
gram is GNU find for example, the -print0 option does this for you.

   find /tmp -name core -type f -print | xargs /bin/rm -f

Find  files named core in or below the directory /tmp and delete them.  Note that this will work incorrectly
if there are any filenames containing newlines or spaces.

   find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f

Find files named core in or below the directory /tmp and delete them, processing filenames  in  such  a  way
that file or directory names containing spaces or newlines are correctly handled.

+ (())
Evaluate integer expression between $[ ].
    a=3
    b=7
    echo (($a+$b)) # 10
    echo (($a*$b)) # 21
