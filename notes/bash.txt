ABS READING NOTE
================

+ How to use double or single bracket, parentheses, curly braces
http://stackoverflow.com/questions/2188199/how-to-use-double-or-single-bracket-parentheses-curly-braces

Brackets
	if [ CONDITION ]    Test construct  
	if [[ CONDITION ]]  Extended test construct  
	Array[1]=element1   Array initialization  
	[a-z]               Range of characters within a Regular Expression  

Curly Brackets
	${variable}                             Parameter substitution  
	${!variable}                            Indirect variable reference  
	{ command1; command2; . . . commandN; } Block of code  
	{string1,string2,string3,...}           Brace expansion  
	{a..z}                                  Extended brace expansion
	{}                                      Text replacement, after find and xargs

Parentheses
	( command1; command2 )             Command group executed within a subshell  
	Array=(element1 element2 element3) Array initialization  
	result=$(COMMAND)                  Command substitution, new style  
	>(COMMAND)                         Process substitution  
	<(COMMAND)                         Process substitution  

Double Parentheses
	(( var = 78 ))            Integer arithmetic   
	var=$(( 20 + 5 ))         Integer arithmetic, with variable assignment   
	(( var++ ))               C-style variable increment   
	(( var-- ))               C-style variable decrement   
	(( var0 = var1<98?9:21 )) C-style trinary operation

+ ,
	1 let "t2 = ((a = 9, 15 / 3))" # Set "a = 9" and "t2 = 15 / 3"

+ ,
for file in /{,usr/}bin/*calc
# Find all executable files ending in "calc"
# in /bin and /usr/bin directories.

+ :
It may be considered a synonym for the shell builtin true. The ":" command is itself a Bash builtin, and
its exit status is true (0).
	while true # equal while :

+ :
	: ${HOSTNAME?} ${USER?} ${MAIL?}
	# Prints error message
	#+ if one or more of essential environmental variables not set.

+ :
	: > data.xxx
	# File "data.xxx" now empty.
	# Same effect as
	cat /dev/null >data.xxx
	# However, this does not fork a new process, since ":" is a builtin.

+ *
	echo "Using *"; echo
	for filename in *
	do
	echo "$filename"
	done
	# Lists only files in current directory ($PWD).
	echo; echo "--------------"; echo
	echo "Using **"
	for filename in **
	do
	echo "$filename"
	done
	# Lists complete file tree, recursively.

+ ? 
In a double-parentheses construct, the ? can serve as an element of a C-style trinary operator.
	(( var0 = var1<98?9:21 ))

+ $'...'
The $' ... ' quoted string-expansion construct is a mechanism that uses escaped
octal or hex values to assign ASCII characters to variables, e.g., quote=$'\042'.
	echo $'\042' # echo -e "\042"

+ $$
process ID variable. The $$ variable holds the process ID [19] of the script in which it appears.
	echo $$$$$$$ # Output "<PID><PID><PID>$"

+ ()
A listing of commands within parentheses starts a _subshell_.
	(a=hello; echo $a)

array initialization.
    Array=(element1 element2 element3)

+ {xxx,yyy,zzz,...}
    cat aaa{a,b,c} > b # equal cat aaaa aaab aaac > b

#No spaces allowed within the braces unless the spaces are quoted or escaped.
    echo {file1,file2}\ :{\ A," B",' C'}
    #file1 : A file1 : B file1 : C file2 : A file2 : B file2 : C

	#bash version 3+. 
    echo {a..z} # a b c d e f g h i j k l m n o p q r s t u v w x y z

# Initializing an array, using extended brace expansion.
    base64_charset=( {A..Z} {a..z} {0..9} + / = )

# Placeholder for text
ls . | xargs -i -t rm my_dir1/my_dir2/{}

+ xargs
Because Unix filenames can contain blanks and newlines, this default behaviour is often  problematic;  file‐
names  containing blanks and/or newlines are incorrectly processed by xargs.  In these situations it is bet‐
ter to use the -0 option, which prevents such problems.   When using this option you  will  need  to  ensure
that the program which produces the input for xargs also uses a null character as a separator.  If that pro‐
gram is GNU find for example, the -print0 option does this for you.

   find /tmp -name core -type f -print | xargs /bin/rm -f

Find  files named core in or below the directory /tmp and delete them.  Note that this will work incorrectly
if there are any filenames containing newlines or spaces.

   find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f

Find files named core in or below the directory /tmp and delete them, processing filenames  in  such  a  way
that file or directory names containing spaces or newlines are correctly handled.

+ (())
Evaluate integer expression between ((...)).
    a=3
    b=7
    echo (($a+$b)) # 10 $[...] is deprecated
    echo (($a*$b)) # 21

+ &>
This is useful for suppressing output when testing for a condition. For example, let us
test whether a certain command exists.
    type bogus_command &>/dev/null
    echo $?

+ 
#-------------------------------------------------------------------------
# No space permitted on either side of = sign when initializing variables.
# What happens if there is a space?
# "VARIABLE =value"
#
#% Script tries to run "VARIABLE" command with one argument, "=value".
# "VARIABLE= value"
#
#% Script tries to run "value" command with
#+ the environmental variable "VARIABLE" set to "".
#-------------------------------------------------------------------------

+ 
# =======================================
# Quoting a variable preserves whitespace.
# =======================================
# Notice the effect of different types of quoting.
    hello="A B C   D"
    hello=A B C   D # gives an error
    hello=A\ B\ C\ \ \ D # also works
    echo $hello # A B C D
    echo "$hello" # A B C   D
    echo '$hello' # $hello

# in FOR operation, the delimiter is whitespace.
# so if $DATA was:
#   aaa
#   bbb
#   ccc
for LINE in $DATA # LINE=aaa, LINE=bbb, LINE=ccc
for LINE in "$DATA" # a whole variable

+ (()) and let
	(( 0 && 1 ))	# Logical AND
	echo $?  # 1 ***
	# And so ...
	let "num = (( 0 && 1 ))"
	echo $num # 0
	# But ...
	let "num = (( 0 && 1 ))"
	echo $?  # 1 ***

	(( 200 || 11 ))  # Logical OR
	echo $?  # 0 ***
	# ...
	let "num = (( 200 || 11 ))"
	echo $num # 1
	let "num = (( 200 || 11 ))"
	echo $?  # 0 ***


	(( 200 | 11 ))  # Bitwise OR
	echo $?    # 0
	# ...
	let "num = (( 200 | 11 ))"
	echo $num  # 203
	let "num = (( 200 | 11 ))"
	echo $?    # 0 ***

	# The "let" construct returns the same exit status
	#+ as the double-parentheses arithmetic expansion.

	# Again, note that the exit status of an arithmetic expression is not an error value.
	var=-2 && (( var+=2 ))
	echo $?  # 1

	var=-2 && (( var+=2 )) && echo $var # Will not echo $var!

+ What is truth in "[...]"
	echo "Testing \"0\""
	if [ 0 ] # zero
	then
	echo "0 is true."
	else
	echo "0 is false."
	fi # 0 is true.

	echo "Testing \"1\""
	if [ 1 ] # one
	then
	echo "1 is true."
	else
	echo "1 is false."
	fi # 1 is true.

+ "[[...]]"
Using the [[ ... ]] test construct, rather than [ ... ] can prevent many logic errors in scripts. For example, the &&, ||, <, and > operators work within a [[ ]] test, despite giving an error within a [ ] construct.
	if [ $condition1 ] && [ $condition2 ]
	# Same as: if [ $condition1 -a $condition2 ]
	# Returns true if both condition1 and condition2 hold true...

	if [[ $condition1 && $condition2 ]]
	 # Also works.
	# Note that && operator not permitted inside brackets
	#+ of [ ... ] construct.



+ if COMMAND
	# The "if COMMAND" construct returns the exit status of COMMAND.
	dir=/home/bozo
	if cd "$dir" 2>/dev/null; then # "2>/dev/null" hides error message.
		echo "Now in $dir."
	else
		echo "Can't change to $dir."
	fi

+ **
	#exponentiation
	let "z=5**3"
	echo "z=$z" # z = 125
				# "expr 5 ** 3" will return error

+ 
#
# An uninitialized variable has no value,
#+ however it evaluates as 0 in an arithmetic operation.
    if [ -z "$unassigned" ]
    then
    echo "\$unassigned is NULL."
    fi
    # $unassigned is NULL.

    echo "$uninitialized" # (blank line)
    let "uninitialized += 5" # Add 5 to it.
    echo "$uninitialized" # 5

+ IFS
	# However ...
	# $IFS treats whitespace differently than other characters.
	output_args_one_per_line()
	{
	for arg
	do
	echo "[$arg]"
	done # ^ ^ Embed within brackets, for your viewing pleasure.
	}

	echo; echo "IFS=\" \""
	echo "-------"

	IFS=" "
	var=" a   b c   "

	output_args_one_per_line $var
	# [a]
	# [b]
	# [c]

	echo; echo "IFS=:"
	echo "-----"
	IFS=:
	var=":a::b:c:::"

	output_args_one_per_line $var
	# []
	# [a]
	# []
	# [b]
	# [c]
	# []
	# []

+ $* $@
$*: All of the positional parameters, seen as a single word
$@: Same as $*, but each parameter is a quoted string, that is, the parameters are passed on intact, without
	interpretation or expansion. This means, among other things, that each parameter in the argument list
	is seen as a separate word.

+ $!
PID (process ID) of last job run in background
	possibly_hanging_job & {
	while ((count < TIMEOUT )); do
		eval '[ ! -d "/proc/$lastjob" ] && ((count = TIMEOUT))'
		lastjob=$!
		((count++))
		sleep 1
	done
	eval '[ -d "/proc/$lastjob" ] && kill -15 $lastjob'
	}

+ declare(only in BASH)
	# Certain arithmetic operations are permitted for declared integer variables without the need for expr or
let.
	declare -i n
	n=6/3 
	echo "n = $n"  # n = 2

	# A declare -f line with no arguments in a script causes a listing of all the functions previously
	defined in that script.

+ random in openwrt
generate max 3 digit number: $(head -30 /dev/urandom | tr -dc "0123456789" | head -c3)

+ printf format
http://www.codingunit.com/printf-format-specifiers-format-conversions-and-formatted-output

FORMAT STRING
The printf(“:%s:\n”, “Hello, world!”); statement prints the string (nothing special happens.)
The printf(“:%15s:\n”, “Hello, world!”); statement prints the string, but print 15 characters. If the string is smaller the “empty” positions will be filled with “whitespace.”
The printf(“:%.10s:\n”, “Hello, world!”); statement prints the string, but print only 10 characters of the string.
The printf(“:%-10s:\n”, “Hello, world!”); statement prints the string, but prints at least 10 characters. If the string is smaller “whitespace” is added at the end. (See next example.)
The printf(“:%-15s:\n”, “Hello, world!”); statement prints the string, but prints at least 15 characters. The string in this case is shorter than the defined 15 character, thus “whitespace” is added at the end (defined by the minus sign.)
The printf(“:%.15s:\n”, “Hello, world!”); statement prints the string, but print only 15 characters of the string. In this case the string is shorter than 15, thus the whole string is printed.
The printf(“:%15.10s:\n”, “Hello, world!”); statement prints the string, but print 15 characters.
If the string is smaller the “empty” positions will be filled with “whitespace.” But it will only print a maximum of 10 characters, thus only part of new string (old string plus the whitespace positions) is printed.
The printf(“:%-15.10s:\n”, “Hello, world!”); statement prints the string, but it does the exact same thing as the previous statement, accept the “whitespace” is added at the end.

	main()
	{
		printf(":%s:\n", "Hello, world!");
		printf(":%15s:\n", "Hello, world!");
		printf(":%.10s:\n", "Hello, world!");
		printf(":%-10s:\n", "Hello, world!");
		printf(":%-15s:\n", "Hello, world!");
		printf(":%.15s:\n", "Hello, world!");
		printf(":%15.10s:\n", "Hello, world!");
		printf(":%-15.10s:\n", "Hello, world!");
	}

	:Hello, world!:
	:  Hello, world!:
	:Hello, wor:
	:Hello, world!:
	:Hello, world!  :
	:Hello, world!:
	:     Hello, wor:
	:Hello, wor     :

+ Manipulating Strings and Parameter Operation

+ set
# The "--" prevents nasty surprises if $planet is null or
#+ begins with a dash.
	set -- $XXX

+ for loop
#If the [list] in a for loop contains wild cards (* and ?) used in filename expansion, then globbing
takes place.
	for file in [jx]*
	do
	rm -f $file # Removes only files beginning with "j" or "x" in $PWD.
	echo "Removed file \"$file\"".
	done

# Missing in [list] in a for loop
# The 'in list' missing, therefore the loop operates on '$@'
#+ (command-line argument list, including whitespace).
	for arg
	do
		echo -n "$arg"
	done

# C-like syntax
	for ((a=1, b=1; a <= LIMIT ; a++, b++))
	do # The comma concatenates operations.
		echo -n "$a-$b "
	done

+ while loop
# C-like syntax
while (( a <= LIMIT ))
do
	echo -n "$a "
	((a += 1))
done

#A while loop may have its stdin redirected to a file by a < at its end.
#A while loop may have its stdin supplied by a pipe.
